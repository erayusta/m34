"use strict";

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

/**
 * Get the pages of data
 *
 * @param {any} url
 * @param {number} [page=1]
 * @returns
 */
var getPages = function () {
  var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(url) {
    var page = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

    var result, getOptions, options, _ref7, headers, data, wpTotal, total, totalPages, requests;

    return _regenerator2.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            result = [];

            getOptions = function getOptions(page) {
              var o = {
                method: `get`,
                url: `${url}?${querystring.stringify({
                  per_page: _perPage,
                  page: page
                })}`
              };
              if (_hostingWPCOM) {
                o.headers = {
                  Authorization: `Bearer ${_accessToken}`
                };
              } else {
                o.auth = _auth ? { username: _auth.htaccess_user, password: _auth.htaccess_pass } : null;
              }
              return o;
            };

            // Initial request gets the first page of data
            // but also the total count of objects, used for
            // multiple concurrent requests (rather than waterfall)


            options = getOptions(page);
            _context2.next = 6;
            return axios(options);

          case 6:
            _ref7 = _context2.sent;
            headers = _ref7.headers;
            data = _ref7.data;


            result = result.concat(data);

            // Some resources have no paging, e.g. `/types`
            wpTotal = headers[`x-wp-total`];
            total = parseInt(wpTotal);
            totalPages = parseInt(headers[`x-wp-totalpages`]);

            if (!(!wpTotal || totalPages <= 1)) {
              _context2.next = 15;
              break;
            }

            return _context2.abrupt("return", result);

          case 15:

            if (_verbose) {
              console.log(`\nTotal entities :`, total);
              console.log(`Pages to be requested :`, totalPages);
            }

            // We got page 1, now we want pages 2 through totalPages
            requests = _.range(2, totalPages + 1).map(function (getPage) {
              var options = getOptions(getPage);
              return axios(options);
            });
            return _context2.abrupt("return", Promise.all(requests).then(function (pages) {
              var data = pages.map(function (page) {
                return page.data;
              });
              data.forEach(function (list) {
                result = result.concat(list);
              });
              return result;
            }));

          case 20:
            _context2.prev = 20;
            _context2.t0 = _context2["catch"](0);
            return _context2.abrupt("return", httpExceptionHandler(_context2.t0));

          case 23:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this, [[0, 20]]);
  }));

  return function getPages(_x4) {
    return _ref6.apply(this, arguments);
  };
}();

/**
 * Gets wordpress.com access token so it can fetch private data like medias :/
 *
 * @returns
 */


var getWPCOMAccessToken = function () {
  var _ref8 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
    var result, oauthUrl, options;
    return _regenerator2.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            result = void 0;
            oauthUrl = `https://public-api.wordpress.com/oauth2/token`;
            _context3.prev = 2;
            options = {
              url: oauthUrl,
              method: `post`,
              data: querystring.stringify({
                client_secret: _auth.wpcom_app_clientSecret,
                client_id: _auth.wpcom_app_clientId,
                username: _auth.wpcom_user,
                password: _auth.wpcom_pass,
                grant_type: `password`
              })
            };
            _context3.next = 6;
            return axios(options);

          case 6:
            result = _context3.sent;

            result = result.data.access_token;
            _context3.next = 13;
            break;

          case 10:
            _context3.prev = 10;
            _context3.t0 = _context3["catch"](2);

            httpExceptionHandler(_context3.t0);

          case 13:
            return _context3.abrupt("return", result);

          case 14:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this, [[2, 10]]);
  }));

  return function getWPCOMAccessToken() {
    return _ref8.apply(this, arguments);
  };
}();

/**
 * Handles HTTP Exceptions (axios)
 *
 * @param {any} e
 */


/**
 * Fetch the data from specified route url, using the auth provided.
 *
 * @param {any} route
 * @param {any} createNode
 * @param {any} parentNodeId (Optional parent node ID)
 */
var fetchData = function () {
  var _ref10 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(route, createNode, parentNodeId) {
    var type, url, routeResponse, _iterator4, _isArray4, _i4, _ref11, ent, length;

    return _regenerator2.default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            type = route.type;
            url = route.url;


            if (parentNodeId != undefined) {
              if (_verbose) console.log(colorized.out(`Extended node content`, colorized.color.Font.FgBlue), url);
            } else {
              if (_verbose) console.log(colorized.out(`=== [ Fetching ${type} ] ===`, colorized.color.Font.FgBlue), url);
              if (_verbose) console.time(`Fetching the ${type} took`);
            }

            _context4.next = 5;
            return getPages(url, 1);

          case 5:
            routeResponse = _context4.sent;

            if (!routeResponse) {
              _context4.next = 31;
              break;
            }

            if (!Array.isArray(routeResponse)) {
              _context4.next = 26;
              break;
            }

            _iterator4 = routeResponse, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();

          case 9:
            if (!_isArray4) {
              _context4.next = 15;
              break;
            }

            if (!(_i4 >= _iterator4.length)) {
              _context4.next = 12;
              break;
            }

            return _context4.abrupt("break", 24);

          case 12:
            _ref11 = _iterator4[_i4++];
            _context4.next = 19;
            break;

          case 15:
            _i4 = _iterator4.next();

            if (!_i4.done) {
              _context4.next = 18;
              break;
            }

            return _context4.abrupt("break", 24);

          case 18:
            _ref11 = _i4.value;

          case 19:
            ent = _ref11;
            _context4.next = 22;
            return createGraphQLNode(ent, type, createNode, parentNodeId);

          case 22:
            _context4.next = 9;
            break;

          case 24:
            _context4.next = 28;
            break;

          case 26:
            _context4.next = 28;
            return createGraphQLNode(routeResponse, type, createNode, parentNodeId);

          case 28:

            // TODO : Get the number of created nodes using the nodes in state.
            length = void 0;

            if (routeResponse && Array.isArray(routeResponse)) {
              length = routeResponse.length;
            } else if (routeResponse && !Array.isArray(routeResponse)) {
              length = Object.keys(routeResponse).length;
            }
            console.log(colorized.out(` -> ${type} fetched : ${length}`, colorized.color.Font.FgGreen));

          case 31:

            if (_verbose && !parentNodeId) {
              console.timeEnd(`Fetching the ${type} took`);
            }

          case 32:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));

  return function fetchData(_x5, _x6, _x7) {
    return _ref10.apply(this, arguments);
  };
}();

/**
 * Encrypts a String using md5 hash of hexadecimal digest.
 *
 * @param {any} str
 */


function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var axios = require(`axios`);
var crypto = require(`crypto`);
var querystring = require(`querystring`);
var _ = require(`lodash`);
var stringify = require(`json-stringify-safe`);
var colorized = require(`./output-color`);

var typePrefix = `wordpress__`;

var conflictFieldPrefix = `wordpress_`;
// restrictedNodeFields from here https://www.gatsbyjs.org/docs/node-interface/
var restrictedNodeFields = [`id`, `children`, `parent`, `fields`, `internal`];

/* If true, will output many console logs. */
var _verbose = void 0;
var _siteURL = void 0;
var _getNode = void 0;
var _useACF = void 0;
var _hostingWPCOM = void 0;
var _auth = void 0;
var _perPage = void 0;
var _accessToken = void 0;

var _parentChildNodes = [];

var refactoredEntityTypes = {
  post: `${typePrefix}POST`,
  page: `${typePrefix}PAGE`,
  tag: `${typePrefix}TAG`,
  category: `${typePrefix}CATEGORY`

  // ========= Main ===========
};exports.sourceNodes = function () {
  var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(_ref, _ref2) {
    var boundActionCreators = _ref.boundActionCreators,
        getNode = _ref.getNode,
        store = _ref.store;
    var baseUrl = _ref2.baseUrl,
        protocol = _ref2.protocol,
        hostingWPCOM = _ref2.hostingWPCOM,
        useACF = _ref2.useACF,
        auth = _ref2.auth,
        verboseOutput = _ref2.verboseOutput,
        _ref2$perPage = _ref2.perPage,
        perPage = _ref2$perPage === undefined ? 100 : _ref2$perPage;

    var createNode, touchNode, setPluginStatus, createParentChildLink, url, allRoutes, options, validRoutes, _iterator, _isArray, _i, _ref4, route, _iterator2, _isArray2, _i2, _ref5, item;

    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            createNode = boundActionCreators.createNode, touchNode = boundActionCreators.touchNode, setPluginStatus = boundActionCreators.setPluginStatus, createParentChildLink = boundActionCreators.createParentChildLink;

            _verbose = verboseOutput;
            _siteURL = `${protocol}://${baseUrl}`;
            _getNode = getNode;
            _useACF = useACF;
            _hostingWPCOM = hostingWPCOM;
            _auth = auth;
            _perPage = perPage;

            // If the site is hosted on wordpress.com, the API Route differs.
            // Same entity types are exposed (excepted for medias and users which need auth)
            // but the data model contain slights variations.
            url = void 0;

            if (!hostingWPCOM) {
              _context.next = 16;
              break;
            }

            url = `https://public-api.wordpress.com/wp/v2/sites/${baseUrl}`;
            _context.next = 13;
            return getWPCOMAccessToken();

          case 13:
            _accessToken = _context.sent;
            _context.next = 17;
            break;

          case 16:
            url = `${_siteURL}/wp-json`;

          case 17:

            if (_verbose) console.log();
            if (_verbose) console.log(colorized.out(`=START PLUGIN=====================================`, colorized.color.Font.FgBlue));
            if (_verbose) console.time(`=END PLUGIN=====================================`);
            if (_verbose) console.log(``);
            if (_verbose) console.log(colorized.out(`Site URL: ${_siteURL}`, colorized.color.Font.FgBlue));
            if (_verbose) console.log(colorized.out(`Site hosted on Wordpress.com: ${hostingWPCOM}`, colorized.color.Font.FgBlue));
            if (_verbose) console.log(colorized.out(`Using ACF: ${useACF}`, colorized.color.Font.FgBlue));
            if (_verbose) console.log(colorized.out(`Using Auth: ${_auth.htaccess_user} ${_auth.htaccess_pass}`, colorized.color.Font.FgBlue));
            if (_verbose) console.log(colorized.out(`Verbose output: ${verboseOutput}`, colorized.color.Font.FgBlue));
            if (_verbose) console.log(``);
            if (_verbose) console.log(colorized.out(`Mama Route URL: ${url}`, colorized.color.Font.FgBlue));
            if (_verbose) console.log(``);

            // Touch existing Wordpress nodes so Gatsby doesn`t garbage collect them.
            _.values(store.getState().nodes).filter(function (n) {
              return n.internal.type.slice(0, 10) === typePrefix;
            }).forEach(function (n) {
              return touchNode(n.id);
            });

            // Call the main API Route to discover the all the routes exposed on this API.
            allRoutes = void 0;
            _context.prev = 31;
            options = {
              method: `get`,
              url: url
            };

            if (_auth) {
              options.auth = {
                username: _auth.htaccess_user,
                password: _auth.htaccess_pass
              };
            }
            _context.next = 36;
            return axios({
              method: `get`,
              url: url
            });

          case 36:
            allRoutes = _context.sent;
            _context.next = 42;
            break;

          case 39:
            _context.prev = 39;
            _context.t0 = _context["catch"](31);

            httpExceptionHandler(_context.t0);

          case 42:
            if (!allRoutes) {
              _context.next = 83;
              break;
            }

            validRoutes = getValidRoutes(allRoutes, url, baseUrl);


            if (_verbose) console.log(``);
            if (_verbose) console.log(colorized.out(`Fetching the JSON data from ${validRoutes.length} valid API Routes...`, colorized.color.Font.FgBlue));
            if (_verbose) console.log(``);

            _iterator = validRoutes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();

          case 48:
            if (!_isArray) {
              _context.next = 54;
              break;
            }

            if (!(_i >= _iterator.length)) {
              _context.next = 51;
              break;
            }

            return _context.abrupt("break", 64);

          case 51:
            _ref4 = _iterator[_i++];
            _context.next = 58;
            break;

          case 54:
            _i = _iterator.next();

            if (!_i.done) {
              _context.next = 57;
              break;
            }

            return _context.abrupt("break", 64);

          case 57:
            _ref4 = _i.value;

          case 58:
            route = _ref4;
            _context.next = 61;
            return fetchData(route, createNode);

          case 61:
            if (_verbose) console.log(``);

          case 62:
            _context.next = 48;
            break;

          case 64:
            _iterator2 = _parentChildNodes, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();

          case 65:
            if (!_isArray2) {
              _context.next = 71;
              break;
            }

            if (!(_i2 >= _iterator2.length)) {
              _context.next = 68;
              break;
            }

            return _context.abrupt("break", 79);

          case 68:
            _ref5 = _iterator2[_i2++];
            _context.next = 75;
            break;

          case 71:
            _i2 = _iterator2.next();

            if (!_i2.done) {
              _context.next = 74;
              break;
            }

            return _context.abrupt("break", 79);

          case 74:
            _ref5 = _i2.value;

          case 75:
            item = _ref5;

            createParentChildLink({
              parent: _getNode(item.parentId),
              child: _getNode(item.childNodeId)
            });

          case 77:
            _context.next = 65;
            break;

          case 79:

            setPluginStatus({
              status: {
                lastFetched: new Date().toJSON()
              }
            });

            if (_verbose) console.timeEnd(`=END PLUGIN=====================================`);
            _context.next = 84;
            break;

          case 83:
            console.log(colorized.out(`No routes to fetch. Ending.`, colorized.color.Font.FgRed));

          case 84:
            return _context.abrupt("return");

          case 85:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, undefined, [[31, 39]]);
  }));

  return function (_x, _x2) {
    return _ref3.apply(this, arguments);
  };
}();function httpExceptionHandler(e) {
  var _e$response = e.response,
      status = _e$response.status,
      statusText = _e$response.statusText,
      message = _e$response.data.message;

  if (_verbose) console.log(colorized.out(`The server response was "${status} ${statusText}"`, colorized.color.Font.FgRed));
  if (message) {
    if (_verbose) console.log(colorized.out(`Inner exception message : "${message}"`, colorized.color.Font.FgRed));
  }
}

/**
 * Extract valid routes and format its data.
 *
 * @param {any} allRoutes
 * @param {any} url
 * @param {any} baseUrl
 * @returns
 */
function getValidRoutes(allRoutes, url, baseUrl) {
  var validRoutes = [];

  for (var _iterator3 = Object.keys(allRoutes.data.routes), _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
    var _ref9;

    if (_isArray3) {
      if (_i3 >= _iterator3.length) break;
      _ref9 = _iterator3[_i3++];
    } else {
      _i3 = _iterator3.next();
      if (_i3.done) break;
      _ref9 = _i3.value;
    }

    var key = _ref9;

    if (_verbose) console.log(`Route discovered :`, key);
    var route = allRoutes.data.routes[key];

    // A valid route exposes its _links (for now)
    if (route._links) {
      var entityType = getRawEntityType(route);

      // Excluding the "technical" API Routes
      var excludedTypes = [undefined, `v2`, `v3`, `1.0`, `2.0`, `embed`, `proxy`, ``, baseUrl];
      if (!excludedTypes.includes(entityType)) {
        if (_verbose) console.log(colorized.out(`Valid route found. Will try to fetch.`, colorized.color.Font.FgGreen));

        var manufacturer = getManufacturer(route);

        var rawType = ``;
        if (manufacturer === `wp`) {
          rawType = `${typePrefix}${entityType}`;
        }

        var validType = void 0;
        switch (rawType) {
          case `${typePrefix}posts`:
            validType = refactoredEntityTypes.post;
            break;
          case `${typePrefix}pages`:
            validType = refactoredEntityTypes.page;
            break;
          case `${typePrefix}tags`:
            validType = refactoredEntityTypes.tag;
            break;
          case `${typePrefix}categories`:
            validType = refactoredEntityTypes.category;
            break;
          default:
            validType = `${typePrefix}${manufacturer.replace(/-/g, `_`)}_${entityType.replace(/-/g, `_`)}`;
            break;
        }
        validRoutes.push({ url: route._links.self, type: validType });
      } else {
        if (_verbose) console.log(colorized.out(`Invalid route.`, colorized.color.Font.FgRed));
      }
    } else {
      if (_verbose) console.log(colorized.out(`Invalid route.`, colorized.color.Font.FgRed));
    }
  }

  if (_useACF) {
    // The OPTIONS ACF API Route is not giving a valid _link so let`s add it manually.
    validRoutes.push({
      url: `${url}/acf/v2/options`,
      type: `${typePrefix}acf_options`
    });
    if (_verbose) console.log(colorized.out(`Added ACF Options route.`, colorized.color.Font.FgGreen));
    if (_hostingWPCOM) {
      // TODO : Need to test that out with ACF on Wordpress.com hosted site. Need a premium account on wp.com to install extensions.
      if (_verbose) console.log(colorized.out(`The ACF options pages is untested under wordpress.com hosting. Please let me know if it works.`, colorized.color.Effect.Blink));
    }
  }

  return validRoutes;
}

/**
 * Extract the raw entity type from route
 *
 * @param {any} route
 */
var getRawEntityType = function getRawEntityType(route) {
  return route._links.self.substring(route._links.self.lastIndexOf(`/`) + 1, route._links.self.length);
};

/**
 * Extract the route manufacturer
 *
 * @param {any} route
 */
var getManufacturer = function getManufacturer(route) {
  return route.namespace.substring(0, route.namespace.lastIndexOf(`/`));
};var digest = function digest(str) {
  return crypto.createHash(`md5`).update(str).digest(`hex`);
};

/**
 * Create the Graph QL Node
 *
 * @param {any} ent
 * @param {any} type
 * @param {any} createNode
 * @param {any} parentNodeId (Optionnal parent node ID)
 */
function createGraphQLNode(ent, type, createNode, parentNodeId) {
  var id = !ent.id ? !ent.ID ? 0 : ent.ID : ent.id;
  var node = {
    id: `${type}_${id.toString()}`,
    children: [],
    parent: `__SOURCE__`,
    internal: {
      type: type
    }
  };

  if (type === refactoredEntityTypes.post) {
    node.id = `POST_${ent.id.toString()}`;
    node.internal.type = refactoredEntityTypes.post;
  } else if (type === refactoredEntityTypes.page) {
    node.id = `PAGE_${ent.id.toString()}`;
    node.internal.type = refactoredEntityTypes.page;
  } else if (type === refactoredEntityTypes.tag) {
    node.id = `TAG_${ent.id.toString()}`;
    node.internal.type = refactoredEntityTypes.tag;
  } else if (type === refactoredEntityTypes.category) {
    node.id = `CATEGORY_${ent.id.toString()}`;
    node.internal.type = refactoredEntityTypes.category;
  }

  node = addFields(ent, node, createNode);

  if (type === refactoredEntityTypes.post || type === refactoredEntityTypes.page) {
    // TODO : Move this to field recursive and add other fields that have rendered field
    node.title = ent.title.rendered;
    node.content = ent.content.rendered;
    node.excerpt = ent.excerpt.rendered;
  }

  node.internal.content = JSON.stringify(node);
  node.internal.contentDigest = digest(stringify(node));
  createNode(node);

  if (parentNodeId) {
    _parentChildNodes.push({ parentId: parentNodeId, childNodeId: node.id });
  }
}

/**
 * Loop through fields to validate naming conventions and extract child nodes.
 *
 * @param {any} ent
 * @param {any} newEnt
 * @param {function} createNode
 * @returns the new entity with fields
 */
function addFields(ent, newEnt, createNode) {
  newEnt = recursiveAddFields(ent, newEnt);

  // TODO : add other types of child nodes
  if (_useACF && ent.acf != undefined && ent.acf != `false`) {
    //Create a child node with acf field json
    var acfNode = {
      id: `${newEnt.id}_ACF_Field`,
      children: [],
      parent: newEnt.id,
      internal: {
        type: `${typePrefix}ACF_Field`,
        content: JSON.stringify(ent.acf)
      }
    };
    acfNode.internal.contentDigest = digest(stringify(acfNode));
    createNode(acfNode);
    _parentChildNodes.push({ parentId: newEnt.id, childNodeId: acfNode.id });
  } else if (newEnt.meta && newEnt.meta.links && newEnt.meta.links.self) {
    //The entity as a link to more content for this entity
    fetchData({ url: newEnt.meta.links.self, type: `${newEnt.internal.type}_Extended` }, createNode, newEnt.id);
  }
  return newEnt;
}

/**
 * Add fields recursively
 *
 * @param {any} ent
 * @param {any} newEnt
 * @returns the new node
 */
function recursiveAddFields(ent, newEnt) {
  for (var _iterator5 = Object.keys(ent), _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
    var _ref12;

    if (_isArray5) {
      if (_i5 >= _iterator5.length) break;
      _ref12 = _iterator5[_i5++];
    } else {
      _i5 = _iterator5.next();
      if (_i5.done) break;
      _ref12 = _i5.value;
    }

    var k = _ref12;

    if (!newEnt.hasOwnProperty(k)) {
      (function () {
        var key = getValidName(k);
        if (key !== `acf`) {
          newEnt[key] = ent[k];
          // Nested Objects & Arrays of Objects
          if (typeof ent[key] === `object`) {
            if (!Array.isArray(ent[key]) && ent[key] != null) {
              newEnt[key] = recursiveAddFields(ent[key], {});
            } else if (Array.isArray(ent[key])) {
              if (ent[key].length > 0 && typeof ent[key][0] === `object`) {
                ent[k].map(function (el, i) {
                  newEnt[key][i] = recursiveAddFields(el, {});
                });
              }
            }
          }
        }
      })();
    }
  }
  return newEnt;
}

/**
 * Validate the GraphQL naming convetions & protect specific fields.
 *
 * @param {any} key
 * @returns the valid name
 */
function getValidName(key) {
  var nkey = key;
  var NAME_RX = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
  if (!NAME_RX.test(nkey) || restrictedNodeFields.includes(nkey)) {
    nkey = `${conflictFieldPrefix}${nkey}`.replace(/-|__|:|\.|\s/g, `_`);
    if (_verbose) console.log(colorized.out(`Object with key "${key}" breaks GraphQL naming convention. Renamed to "${nkey}"`, colorized.color.Font.FgRed));
  }
  return nkey;
}